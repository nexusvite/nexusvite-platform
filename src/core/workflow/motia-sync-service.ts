/**
 * Motia Sync Service
 * Synchronizes NexusVite workflows with Motia framework
 * Automatically generates and registers Motia steps for each workflow
 */

import { Node, Edge } from 'reactflow';
import fs from 'fs/promises';
import path from 'path';
import { z } from 'zod';

export interface WorkflowData {
  id: string;
  name: string;
  description?: string;
  nodes: Node[];
  edges: Edge[];
  userId: string;
}

export class MotiaSyncService {
  private motiaStepsDir: string;
  private motiaBaseUrl: string;

  constructor() {
    this.motiaStepsDir = path.join(process.cwd(), 'src', 'steps');
    this.motiaBaseUrl = 'http://localhost:3000';
  }

  /**
   * Sync a complete workflow with Motia
   * Creates step files and registers the workflow
   */
  async syncWorkflow(workflow: WorkflowData): Promise<void> {
    console.log(`[MotiaSyncService] Syncing workflow ${workflow.id} - ${workflow.name}`);

    // 1. Ensure workflows directory exists
    await this.ensureWorkflowsDirectory();

    // 2. Generate step files for each node in the workflow
    const stepFiles = await this.generateWorkflowSteps(workflow);

    // 3. Create a workflow manifest for Motia
    await this.createWorkflowManifest(workflow, stepFiles);

    // 4. Register the workflow with Motia runtime
    await this.registerWithMotiaRuntime(workflow);

    console.log(`[MotiaSyncService] Successfully synced workflow ${workflow.id}`);
  }

  /**
   * Remove a workflow from Motia
   */
  async removeWorkflow(workflowId: string): Promise<void> {
    try {
      // Remove all step files for this workflow
      const files = await fs.readdir(this.motiaStepsDir);
      const workflowFiles = files.filter(f => f.startsWith(`wf_${workflowId}_`));

      for (const file of workflowFiles) {
        await fs.rm(path.join(this.motiaStepsDir, file), { force: true });
      }

      console.log(`[MotiaSyncService] Removed workflow ${workflowId} from Motia`);
    } catch (error) {
      console.error(`[MotiaSyncService] Error removing workflow ${workflowId}:`, error);
    }
  }

  /**
   * Ensure the workflows directory exists
   */
  private async ensureWorkflowsDirectory(): Promise<void> {
    try {
      await fs.mkdir(this.motiaStepsDir, { recursive: true });
    } catch (error) {
      console.error('[MotiaSyncService] Error creating workflows directory:', error);
    }
  }

  /**
   * Generate Motia step files for each node in the workflow
   */
  private async generateWorkflowSteps(workflow: WorkflowData): Promise<string[]> {
    const stepFiles: string[] = [];
    const workflowPrefix = `wf_${workflow.id}`;

    // Remove existing workflow steps before creating new ones
    await this.removeWorkflow(workflow.id);

    for (const node of workflow.nodes) {
      const stepFileName = `${workflowPrefix}_${node.id}.step.ts`;
      const stepFilePath = path.join(this.motiaStepsDir, stepFileName);
      const stepContent = this.generateStepContent(node, workflow);

      await fs.writeFile(stepFilePath, stepContent, 'utf-8');
      stepFiles.push(stepFileName);

      console.log(`[MotiaSyncService] Generated step file: ${stepFileName}`);
    }

    // Generate the main workflow orchestrator step
    const orchestratorFileName = `${workflowPrefix}_orchestrator.step.ts`;
    const orchestratorContent = this.generateOrchestratorStep(workflow);
    const orchestratorPath = path.join(this.motiaStepsDir, orchestratorFileName);
    await fs.writeFile(orchestratorPath, orchestratorContent, 'utf-8');
    stepFiles.push(orchestratorFileName);

    return stepFiles;
  }

  /**
   * Generate step content for a single node
   */
  private generateStepContent(node: Node, workflow: WorkflowData): string {
    const { type, subType, config } = node.data;
    const nodeId = node.id;
    const workflowId = workflow.id;

    // Find connected nodes
    const incomingEdges = workflow.edges.filter(e => e.target === nodeId);
    const outgoingEdges = workflow.edges.filter(e => e.source === nodeId);

    // Generate subscribes and emits based on connections
    const subscribes = incomingEdges.map(e => `workflow.${workflowId}.node.${e.source}.completed`);
    const emits = [`workflow.${workflowId}.node.${nodeId}.completed`];

    // Add workflow start subscription for trigger nodes
    if (type === 'trigger') {
      subscribes.push(`workflow.${workflowId}.start`);
    }

    return `import { z } from 'zod';
import type { ApiRouteConfig, EventConfig, Handlers } from '@motia/core';

/**
 * Workflow Node: ${node.data.label || nodeId}
 * Type: ${type} / ${subType || 'default'}
 * Workflow: ${workflow.name} (${workflowId})
 * Auto-generated by MotiaSyncService
 */

${this.generateStepConfig(node, workflowId, subscribes, emits)}

export const handler: Handlers['wf_${workflowId}_${nodeId}'] = async (req, { logger, emit, state, traceId }) => {
  const workflowId = '${workflowId}';
  const nodeId = '${nodeId}';

  logger.info(\`Executing node \${nodeId} in workflow \${workflowId}\`);

  try {
    // Get workflow state
    const workflowState = await state.getGroup(\`workflow:\${workflowId}\`) || {};

    // Get input data from previous nodes or initial trigger
    const inputData = ${type === 'trigger' ? 'req.body || {}' : 'workflowState.lastOutput || {}'};

    // Execute node logic
    ${this.generateNodeLogic(node)}

    // Store output in workflow state
    await state.set(\`workflow:\${workflowId}\`, 'lastOutput', result);
    await state.set(\`workflow:\${workflowId}\`, \`node:\${nodeId}:output\`, result);

    // Emit completion event for next nodes
    await emit({
      topic: \`workflow.\${workflowId}.node.\${nodeId}.completed\`,
      data: {
        workflowId,
        nodeId,
        output: result,
        timestamp: Date.now(),
        traceId
      }
    });

    return { success: true, output: result };
  } catch (error) {
    logger.error(\`Error executing node \${nodeId}\`, { error: error.message });

    await emit({
      topic: \`workflow.\${workflowId}.node.\${nodeId}.failed\`,
      data: {
        workflowId,
        nodeId,
        error: error.message,
        timestamp: Date.now(),
        traceId
      }
    });

    throw error;
  }
};`;
  }

  /**
   * Generate step configuration based on node type
   */
  private generateStepConfig(node: Node, workflowId: string, subscribes: string[], emits: string[]): string {
    const { type, subType } = node.data;
    const nodeId = node.id;
    const stepName = `wf_${workflowId}_${nodeId}`;

    if (type === 'trigger') {
      if (subType === 'webhook') {
        return `export const config: ApiRouteConfig = {
  type: 'api',
  name: '${stepName}',
  method: 'POST',
  path: '/workflow/${workflowId}/trigger/${nodeId}',
  subscribes: ${JSON.stringify(subscribes)},
  emits: ${JSON.stringify(emits)},
  flows: ['workflow-${workflowId}']
};`;
      } else if (subType === 'cron') {
        return `export const config: CronConfig = {
  type: 'cron',
  name: '${stepName}',
  cron: '${node.data.config?.schedule || '0 * * * *'}',
  subscribes: ${JSON.stringify(subscribes)},
  emits: ${JSON.stringify(emits)},
  flows: ['workflow-${workflowId}']
};`;
      }
    }

    // Default to event type for action/transform/condition nodes
    return `export const config: EventConfig = {
  type: 'event',
  name: '${stepName}',
  subscribes: ${JSON.stringify(subscribes)},
  emits: ${JSON.stringify(emits)},
  flows: ['workflow-${workflowId}']
};`;
  }

  /**
   * Generate node execution logic based on type
   */
  private generateNodeLogic(node: Node): string {
    const { type, subType, config } = node.data;

    switch (type) {
      case 'trigger':
        return `const result = inputData; // Pass through trigger data`;

      case 'action':
        if (subType === 'http') {
          return `// HTTP Request
    const response = await fetch('${config?.url || ''}', {
      method: '${config?.method || 'GET'}',
      headers: ${JSON.stringify(config?.headers || {})},
      body: ${config?.method !== 'GET' ? 'JSON.stringify(inputData)' : 'undefined'}
    });
    const result = await response.json();`;
        } else if (subType === 'email') {
          return `// Email Action (simulated)
    const result = {
      sent: true,
      to: '${config?.to || ''}',
      subject: '${config?.subject || ''}',
      body: inputData
    };`;
        } else if (subType === 'database') {
          return `// Database Query (simulated)
    const result = {
      query: '${config?.query || ''}',
      params: inputData,
      rows: []
    };`;
        }
        break;

      case 'transform':
        if (subType === 'javascript') {
          return `// JavaScript Transform
    const transform = ${config?.code || '(data) => data'};
    const result = transform(inputData);`;
        } else if (subType === 'json') {
          return `// JSON Mapper
    const mapping = ${JSON.stringify(config?.mapping || {})};
    const result = Object.entries(mapping).reduce((acc, [key, path]) => {
      acc[key] = inputData[path];
      return acc;
    }, {});`;
        }
        break;

      case 'condition':
        return `// Condition Evaluation
    const condition = ${config?.expression || 'true'};
    const result = {
      conditionMet: condition,
      data: inputData
    };`;

      default:
        return `const result = inputData; // Pass through`;
    }

    return `const result = inputData; // Default pass through`;
  }

  /**
   * Generate the main orchestrator step for the workflow
   */
  private generateOrchestratorStep(workflow: WorkflowData): string {
    const workflowId = workflow.id;
    const triggerNodes = workflow.nodes.filter(n => n.data.type === 'trigger');

    return `import { z } from 'zod';
import type { ApiRouteConfig, Handlers } from '@motia/core';

/**
 * Workflow Orchestrator: ${workflow.name}
 * ID: ${workflowId}
 * Auto-generated by MotiaSyncService
 */

export const config: ApiRouteConfig = {
  type: 'api',
  name: 'wf_${workflowId}_orchestrator',
  method: 'POST',
  path: '/workflow/${workflowId}/start',
  emits: [
    'workflow.${workflowId}.start',
    ${triggerNodes.map(n => `'workflow.${workflowId}.node.${n.id}.start'`).join(',\n    ')}
  ],
  flows: ['workflow-${workflowId}']
};

export const handler: Handlers['wf_${workflowId}_orchestrator'] = async (
  req,
  { logger, emit, state, traceId }
) => {
  const workflowId = '${workflowId}';

  logger.info(\`Starting workflow \${workflowId}\`);

  // Initialize workflow state
  await state.set(\`workflow:\${workflowId}\`, 'status', 'running');
  await state.set(\`workflow:\${workflowId}\`, 'startedAt', Date.now());
  await state.set(\`workflow:\${workflowId}\`, 'traceId', traceId);

  // Emit workflow start event
  await emit({
    topic: \`workflow.\${workflowId}.start\`,
    data: {
      workflowId,
      input: req.body || {},
      timestamp: Date.now(),
      traceId
    }
  });

  // Start trigger nodes
  ${triggerNodes.map(n => `await emit({
    topic: 'workflow.${workflowId}.node.${n.id}.start',
    data: {
      workflowId,
      nodeId: '${n.id}',
      input: req.body || {},
      timestamp: Date.now(),
      traceId
    }
  });`).join('\n  ')}

  return {
    success: true,
    workflowId,
    message: 'Workflow started successfully',
    traceId
  };
};`;
  }

  /**
   * Create a workflow manifest file for Motia
   */
  private async createWorkflowManifest(workflow: WorkflowData, stepFiles: string[]): Promise<void> {
    const manifestPath = path.join(this.motiaStepsDir, `wf_${workflow.id}_manifest.json`);
    const manifest = {
      id: workflow.id,
      name: workflow.name,
      description: workflow.description,
      version: '1.0.0',
      created: new Date().toISOString(),
      nodes: workflow.nodes.map(n => ({
        id: n.id,
        type: n.data.type,
        subType: n.data.subType,
        label: n.data.label,
        stepFile: `${n.id}.step.ts`
      })),
      edges: workflow.edges,
      steps: stepFiles,
      flows: [`workflow-${workflow.id}`]
    };

    await fs.writeFile(manifestPath, JSON.stringify(manifest, null, 2), 'utf-8');

    console.log(`[MotiaSyncService] Created workflow manifest: ${manifestPath}`);
  }

  /**
   * Register the workflow with Motia runtime
   * This notifies Motia to reload and pick up the new workflow steps
   */
  private async registerWithMotiaRuntime(workflow: WorkflowData): Promise<void> {
    try {
      // Trigger a reload of Motia steps by touching the tutorial.tsx file
      // Motia watches this file and reloads when it changes
      const tutorialPath = path.join(process.cwd(), 'src', 'tutorial.tsx');

      try {
        const content = await fs.readFile(tutorialPath, 'utf-8');
        // Add a comment with timestamp to trigger reload
        const updatedContent = content.replace(
          /\/\/ Last sync:.*/,
          `// Last sync: ${new Date().toISOString()} - Workflow: ${workflow.name}`
        );

        if (updatedContent === content) {
          // If no existing sync comment, add one
          const newContent = `// Last sync: ${new Date().toISOString()} - Workflow: ${workflow.name}\n${content}`;
          await fs.writeFile(tutorialPath, newContent, 'utf-8');
        } else {
          await fs.writeFile(tutorialPath, updatedContent, 'utf-8');
        }
      } catch (error) {
        // If tutorial.tsx doesn't exist, create a minimal one
        const minimalContent = `// Last sync: ${new Date().toISOString()} - Workflow: ${workflow.name}
export const steps = [];
`;
        await fs.writeFile(tutorialPath, minimalContent, 'utf-8');
      }

      console.log(`[MotiaSyncService] Triggered Motia reload for workflow ${workflow.id}`);

      // Also update the motia-workbench.json to include the workflow
      const workbenchPath = path.join(process.cwd(), 'src', 'motia-workbench.json');
      let workbench = { workflows: {} };

      try {
        const existing = await fs.readFile(workbenchPath, 'utf-8');
        workbench = JSON.parse(existing);
      } catch {
        // File doesn't exist or is invalid, use default
      }

      workbench.workflows = workbench.workflows || {};
      workbench.workflows[workflow.id] = {
        id: workflow.id,
        name: workflow.name,
        description: workflow.description,
        path: `workflows/${workflow.id}`,
        created: new Date().toISOString()
      };

      await fs.writeFile(workbenchPath, JSON.stringify(workbench, null, 2), 'utf-8');

    } catch (error) {
      console.error('[MotiaSyncService] Error registering with Motia runtime:', error);
    }
  }
}

// Export singleton instance
export const motiaSyncService = new MotiaSyncService();