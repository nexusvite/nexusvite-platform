---
description: RULES for UI Steps in Motia - Three distinct patterns based on actual codebase implementations
globs: ["**/*.step.tsx", "**/*.step.ts"] 
alwaysApply: true
---
# UI Steps Guide for Motia

## CRITICAL: Three Distinct UI Step Patterns

Based on analysis of actual implementations across all examples, there are **exactly three** valid patterns for UI steps in Motia.

### Pattern 1: Interactive UI Steps (Buttons/Forms that trigger backend logic)

Use this for buttons, forms, or other interactive elements that trigger API calls.

**MANDATORY Two-Step Architecture:**

#### Step 1: The UI Trigger (NOOP type)
**File Structure:**
- `trigger-name.step.ts` (NOOP configuration)  
- `trigger-name.step.tsx` (React component with buttons/forms)

**STRICT Configuration Requirements:**
```typescript
// trigger-name.step.ts
import type { NoopConfig } from 'motia'

export const config: NoopConfig = {
  type: 'noop', // ← MANDATORY: Must be 'noop'
  name: 'Descriptive Trigger Name',
  description: 'Clear description of what this UI does',
  
  // MANDATORY: Required by Motia validation (empty array for trigger-only UI)
  virtualSubscribes: [],
  
  // MANDATORY: Define which API endpoints this UI calls
  virtualEmits: [
    {
      topic: '/api/your-endpoint-path', // ← Must match API step path exactly
      label: 'Human readable action description',
    },
  ],
  
  flows: ['your-flow-name'], // ← Use existing flow for workbench display
}
```

**MULTIPLE VALID REACT COMPONENT PATTERNS:**

**Option A: Default Export with BaseHandle (Most Common)**
```typescript
// trigger-name.step.tsx
import React, { useState } from 'react'
import { BaseHandle, Position } from 'motia/workbench' // ← MANDATORY for workbench connections

export default function TriggerUI() {
  // MANDATORY: State management for UI feedback
  const [status, setStatus] = useState<'idle' | 'loading' | 'success' | 'error'>('idle')
  const [message, setMessage] = useState('')

  const handleAction = async () => {
    setStatus('loading')
    setMessage('')
    
    try {
      // MANDATORY: Use standard fetch API (not custom hooks)
      const response = await fetch('/api/your-endpoint-path', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ source: 'TriggerUI' }),
      })

      const data = await response.json()
      
      if (!response.ok) {
        throw new Error(data.error || `HTTP ${response.status}`)
      }
      
      setStatus('success')
      setMessage(data.message)
    } catch (error) {
      setStatus('error')
      setMessage(error.message)
    }
  }

  return (
    <div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white">
      <div className="text-sm font-medium mb-2">Your UI Title</div>
      <button
        onClick={handleAction}
        disabled={status === 'loading'}
        className="px-3 py-1 bg-blue-600 rounded text-sm hover:bg-blue-700 disabled:bg-gray-500"
      >
        {status === 'loading' ? 'Processing...' : 'Action Button'}
      </button>
      
      {/* MANDATORY: User feedback */}
      {message && (
        <p className={`mt-2 text-xs ${status === 'error' ? 'text-red-400' : 'text-green-400'}`}>
          {message}
        </p>
      )}
      
      {/* MANDATORY: Workbench connection handle */}
      <BaseHandle type="source" position={Position.Bottom} />
    </div>
  )
}
```

**Option B: Named Export with ApiNode**
```typescript
// trigger-name.step.tsx
import React, { useState } from 'react'
import { ApiNode, ApiNodeProps, Button } from 'motia/workbench'

export const Node: React.FC<ApiNodeProps> = ({ data }) => {
  const [isLoading, setIsLoading] = useState(false)
  
  const handleAction = async () => {
    setIsLoading(true)
    try {
      await fetch('/api/your-endpoint-path', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ source: 'UI' }),
      })
    } catch (error) {
      console.error('Error:', error)
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <ApiNode data={data}>
      <div className="flex flex-col gap-2 p-2">
        <Button onClick={handleAction} disabled={isLoading}>
          {isLoading ? 'Processing...' : 'Trigger Action'}
        </Button>
      </div>
    </ApiNode>
  )
}
```

### Pattern 2: Monitor/Display UI Steps (Information display, no API calls)

Use this for status displays, progress monitors, or information dashboards.

**File Structure:**
- `monitor-name.step.ts` (NOOP configuration)
- `monitor-name.step.tsx` (Display-only React component)

**Configuration Requirements:**
```typescript
// monitor-name.step.ts
import type { NoopConfig } from 'motia'

export const config: NoopConfig = {
  type: 'noop',
  name: 'Monitor Name',
  description: 'What this monitor displays',
  
  // OPTIONAL: Define what events this monitor listens to for updates
  virtualSubscribes: [
    'event.topic.to.monitor',
    'another.event.topic'
  ],
  
  // OPTIONAL: Define events this monitor might emit
  virtualEmits: [
    { topic: 'monitor.alert', label: 'Alert triggered' }
  ],
  
  flows: ['your-flow-name'],
}
```

**React Component Pattern:**
```typescript
// monitor-name.step.tsx  
import React, { useState } from 'react'
import { BaseHandle, Position } from 'motia/workbench'

export default function MonitorUI({ data }: EventNodeProps) {
  return (
    <div className="p-4 bg-gray-800 rounded-lg border border-gray-600 text-white">
      <div className="text-sm font-medium mb-2">Monitor Title</div>
      <div className="text-xs text-gray-300 mb-3">Monitor description</div>
      
      {/* Display status, progress, or information */}
      <div className="flex flex-col gap-2">
        <div className="flex items-center">
          <div className="w-2 h-2 rounded-full bg-green-500 mr-2"></div>
          <span className="text-xs">Status Item 1</span>
        </div>
        <div className="flex items-center">
          <div className="w-2 h-2 rounded-full bg-yellow-500 mr-2"></div>
          <span className="text-xs">Status Item 2</span>
        </div>
      </div>
      
      {/* MANDATORY: Connection handles */}
      <BaseHandle type="target" position={Position.Top} />
      <BaseHandle type="source" position={Position.Bottom} />
    </div>
  )
}
```

### Pattern 3: Visualization UI Steps (Custom visual representation of existing steps)

Use this for custom visual representations of existing workflow steps that have their own business logic.

**File Structure:**
- `my-step.step.ts` (main step logic - any type: event, api, cron, etc.)
- `my-step.step.tsx` (optional visual customization)

**Requirements:**
- The `.tsx` file is **optional** and only for visual customization
- Must use `EventNode` from `motia/workbench` as the base component
- Must accept `EventNodeProps` as props
- **DO NOT** add business logic or API calls in visualization components

```typescript
// my-custom-display.step.tsx
import React from 'react'
import { EventNode, type EventNodeProps } from 'motia/workbench'

export default function CustomDisplayUI({ data }: EventNodeProps) {
  return (
    <EventNode
      data={data}
      variant="white"
      shape="rounded"
      className="py-2 px-4 border-blue-500 border-2"
    >
      <div>
        <strong>Custom Step:</strong> {data.label || data.name}
      </div>
      <div className="mt-2 p-2 bg-gray-100 rounded text-center text-sm">
        Custom Visual Content
      </div>
    </EventNode>
  )
}
```

## IMPORT PATTERNS

Multiple valid import patterns are used across the codebase:

**Preferred (stable):**
```typescript
import { BaseHandle, Position, EventNodeProps } from 'motia/workbench'
```

**Alternative (legacy):**
```typescript
import { BaseHandle, Position } from '@motiadev/workbench'
```

## API HANDLER STEP (for Interactive UI Steps)

When creating Interactive UI Steps (Pattern 1), you need a corresponding API step:

**File Structure:**
- `api-handler-name.step.ts` (API endpoint with business logic)

**Configuration Requirements:**
```typescript
// api-handler-name.step.ts
import { z } from 'zod'
import type { ApiRouteConfig, Handlers } from 'motia'

export const config: ApiRouteConfig = {
  type: 'api', // ← MANDATORY: Must be 'api'
  name: 'Descriptive Handler Name',
  description: 'What this API endpoint does',
  path: '/api/your-endpoint-path', // ← Must match UI fetch URL exactly
  method: 'POST', // ← Must match UI fetch method
  
  // MANDATORY: Define events this handler emits
  emits: [
    { topic: 'your.workflow.event', label: 'Event Description' }
  ],

  // MANDATORY: Zod schemas for validation
  bodySchema: z.object({
    source: z.string().optional(),
    // Add other expected fields
  }),
  
  responseSchema: {
    200: z.object({ message: z.string() }),
    500: z.object({ error: z.string() }),
  },
  
  flows: ['your-flow-name'],
}

export const handler: Handlers['Descriptive Handler Name'] = async (req, { emit, logger }) => {
  try {
    logger.info('API handler triggered', { source: req.body.source })

    // Your business logic here
    await emit({
      topic: 'your.workflow.event',
      data: {
        message: 'Processing complete',
        timestamp: new Date().toISOString(),
        // Add other event data
      },
    })

    return {
      status: 200,
      body: { message: 'Success! Event emitted.' },
    }
  } catch (error) {
    logger.error('API handler failed', { error: error.message })
    return {
      status: 500,
      body: { error: 'Internal server error' },
    }
  }
}
```

## EXPORT PATTERNS

**Valid Component Export Patterns:**

1. **Default Export (Most Common):**
```typescript
export default function ComponentName() { }
```

2. **Named Export:**
```typescript
export const Node: React.FC<ApiNodeProps> = ({ data }) => { }
```

## FORBIDDEN PATTERNS

❌ **DO NOT** mix different UI step patterns in the same component
❌ **DO NOT** put business logic in display/monitor components
❌ **DO NOT** use custom API hooks in UI components - use standard `fetch`
❌ **DO NOT** skip error handling in interactive components
❌ **DO NOT** forget `BaseHandle` connections in any UI component
❌ **DO NOT** use types other than `noop` for UI step configurations
❌ **DO NOT** skip state management in interactive components
❌ **DO NOT** omit `virtualSubscribes` array (causes validation errors)
❌ **DO NOT** create new flows without ensuring workbench display (use existing flows)

## MANDATORY CHECKLISTS

### For **Interactive UI Steps** (Pattern 1):
- [ ] UI step config has `type: 'noop'`
- [ ] UI step config has `virtualSubscribes: []` (mandatory for validation)
- [ ] UI step config has `virtualEmits` array with correct API path
- [ ] React component uses `useState` for status/loading
- [ ] React component includes `BaseHandle` for connections
- [ ] React component has proper error handling
- [ ] API step has `type: 'api'` 
- [ ] API step path matches UI fetch URL exactly
- [ ] API step has Zod schemas for validation
- [ ] API step handler has try/catch error handling
- [ ] Both steps are in same flow (use existing flow for workbench display)

### For **Monitor/Display UI Steps** (Pattern 2):
- [ ] UI step config has `type: 'noop'`
- [ ] UI step config has appropriate `virtualSubscribes`
- [ ] React component accepts `EventNodeProps` (optional)
- [ ] React component includes both target and source `BaseHandle`
- [ ] React component is display-only (no API calls)
- [ ] Component focuses on status/information display

### For **Visualization UI Steps** (Pattern 3):
- [ ] Main step file exists with business logic
- [ ] Visualization file is optional
- [ ] Uses `EventNode` as base component
- [ ] Accepts `EventNodeProps` as props
- [ ] No business logic in visualization component

**Failure to follow these patterns will result in non-functional UI steps.**

## COMMON TROUBLESHOOTING

### UI Step Not Appearing in Workbench
- **Check `virtualSubscribes`**: Must be present (empty array `[]` for trigger-only UI)
  ```
  [ERROR] steps/button-trigger.step.ts
  │ ✖ virtualSubscribes: Required
  ```
- **Check Flow Name**: Use existing flow name for immediate workbench display
- **Verify File Structure**: Both `.step.ts` and `.step.tsx` files required

### Button Not Working  
- **API Path Mismatch**: `virtualEmits` topic must exactly match API step path
- **Missing Handlers**: Ensure API handler step exists with matching path
- **Network Issues**: Check browser dev tools for fetch errors

### Events Not Processing
- **Topic Mismatch**: Event step `subscribes` must match API handler `emits`
- **Flow Mismatch**: All connected steps must be in same flow
- **Schema Validation**: Check Zod schemas match emitted data structure

### Successful Working Example
```typescript
// UI Config (button-trigger.step.ts)
export const config: NoopConfig = {
  type: 'noop',
  name: 'ButtonTrigger', 
  virtualSubscribes: [], // ← Required!
  virtualEmits: [{ topic: '/api/button-action', label: 'Button clicked' }],
  flows: ['basic-tutorial'] // ← Use existing flow
}

// API Config (button-handler.step.ts) 
export const config: ApiRouteConfig = {
  type: 'api',
  path: '/api/button-action', // ← Must match exactly
  emits: ['button.triggered'],
  flows: ['basic-tutorial'] // ← Same flow
}
``` 
